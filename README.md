# iOS_ClassicAlgorithms
算法、数据结构题目


#### 1、从1到N，1出现的次数？例如（N=10，出现的1的数分别为，1、10）
 
 
###### 1-1、普通方案：解决方案：使用N%10得余数来计算1出现的次数
 
    int sum = 0；
    while(N % 10 == 1){
      sum++;
      N = N /10;
    }
    //但是此种方法是最原始的方法，时间复杂度（输入数字N,N有O(logn)位，所以复杂度位O(N*logn)），运行效率较低。
    
###### 1-2、优化方案：

    1、2、3、4、5、6、7、8、9;                            1次
    10、11、12、13、14、15、16、17、18、19；              10次
    20、21、22、23、24、25、26、27、28、29；              1次
    ...                                                 1次
    90、91、92、93、94、95、96、97、98、99；              1次     ---（1-99中出现1的次数为10+9）
    
    
    100、101、102、103、104、105、106、107、108、109；   10+1次
    110、111、112、113、114、115、116、117、118、119；   10+10次
    120、121、122、123、124、125、126、127、128、129；   10+1次
    ...                                                10+1次
    190、191、192、193、194、195、196、197、198、199；   10+1次   ---（100-199中出现的次数为100+19）
    
    
    200、201、202、203、204、205、206、207、208、209     1次
    210、211、212、213、214、215、216、217、218、219     10次
    220、221、222、223、224、225、226、227、228、229     1次
    230、231、232、233、234、235、236、237、238、239     1次
    240、241、242、243、244、245、246、247、248、249     1次
    250、251、252、253、254、255、256、257、258、259     1次
    260、261、262、263、264、265、266、267、268、269     1次
    270、271、272、273、274、275、276、277、278、279     1次
    280、281、282、283、284、285、286、287、288、289     1次
    290、291、292、293、294、295、296、297、298、299     1次
 
    判断最高位是否为1、如果位1（例如190，`100至190`出现次数为10*9+(9-1)*1+10*1;`1至100`出现次数(10-1)*1+10*1）
    思路：从数字的最高位、次高位、次次高位...
    
    
#### 2、我们把只包含2、3、5因子的数称作为丑数（Ugly Number）从1開始的10个丑数分别为1，2，3，4，5，6，8，9，10，12

###### 2-1、普通方案(计算每一个数是否丑数)

    //判断是否为丑数
    - (BOOL)isUglyNumber:(NSInteger)uglyNumber{
    
        while(uglyNumber % 2 == 0){
            uglyNumber /= 2;
        }
        
        while(uglyNumber % 3 == 0){
            uglyNumber /= 3;
        }
        
        while(uglyNumber % 5 == 0){
            uglyNumber /= 5;
        }
        
        return (uglyNumber == 1 ? YES:NO);
    }
    
    //计算第多少个丑数
    - (NSInteger)calculateUglyNumberCount:(NSInteger)sumCount{
        NSInteger count = 0;
        NSInteger number = 1;
        while(count != sumCount){
            if([self isUglyNumber:number]){
                count++;
            }
            number++;
        }
        return number - 1;
    }


###### 2-2、优化方案（只对丑数进行判断）
    
    第零步： 1                        再次优化使用一个数组存储计算出来的丑数uglyNumbers[1]
    分析过程 1*2；                            
            1*3；                       
            1*5；                                           取出大于的最小值2
    第一步： 1、2                         uglyNumbers[1,2,3,5]
    分析过程 1*2=2、2*2=4；
            1*3=3、2*3=6；              
            1*5=5、2*5=10；                                 取出大于2的最小值3
    第二步： 1、2、3                       uglyNumbers[1,2,3,4,5,6,10]       
    分析过程 1*2=2、2*2=4、3*2=6；
            1*3=3、2*3=6、3*3=9；       
            1*5=5、2*5=10、3*5=15；                         取出大于3的最小值4
    第三部： 1、2、3、4                    uglyNumbers[1,2,3,4,5,6,9,10,15]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8；     
            1*3=3、2*3=6、3*3=9、4*3=12；
            1*5=5、2*5=10、3*5=15、4*5=20；                 值为5
    第四步： 1、2、3、4、5                  uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,20]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8、5*2=10；
            1*3=3、2*3=6、3*3=9、4*3=12、5*3=15；
            1*5=5、2*5=10、3*5=15、4*5=20、5*5=25；         值为6
    第五步: 1、2、3、4、5、6                uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,20,25]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8、5*2=10、6*2=12；
            1*3=3、2*3=6、3*3=9、4*3=12、5*3=15、6*3=18；
            1*5=5、2*5=10、3*5=15、4*5=20、5*5=25、6*5=30；            值为8
    第六步：1、2、3、4、5、6、8              uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,18,20,25,30]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8、5*2=10、6*2=12、8*2=16；
            1*3=3、2*3=6、3*3=9、4*3=12、5*3=15、6*3=18、8*3=24；
            1*5=5、2*5=10、3*5=15、4*5=20、5*5=25、6*5=30、8*5=40；    值为9
    第七步：1、2、3、4、5、6、8、9           uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,40]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8、5*2=10、6*2=12、8*2=16、9*2=18；
            1*3=3、2*3=6、3*3=9、4*3=12、5*3=15、6*3=18、8*3=24、9*3=27；
            1*5=5、2*5=10、3*5=15、4*5=20、5*5=25、6*5=30、8*5=40、9*5=45； 值为10    
    第八步：1、2、3、4、5、6、8、9、10       uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,40,45]
    分析过程:1*2=2、2*2=4、3*2=6、4*2=8、5*2=10、6*2=12、8*2=16、9*2=18、10*2=20；
            1*3=3、2*3=6、3*3=9、4*3=12、5*3=15、6*3=18、8*3=24、9*3=27、10*3=30；
            1*5=5、2*5=10、3*5=15、4*5=20、5*5=25、6*5=30、8*5=40、9*5=45、10*5=50； 值为12
    第九步：1、2、3、4、5、6、8、9、10、12    uglyNumbers[1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,40,45,50]
    
    
    
#### 3、斐波那契数列计算第N个斐波那契数（0、1、1、2、3、5、8、13、21、33...）

###### 3-1、普通方案（f(10)=f(9)+f(8),从高低一直递归查找0、1终止递归函数；时间复杂度为O(2^n)）
     /**< 1、普通方案计算斐波那契数列 */
     - (NSInteger)normal_fibFucntionIndex:(NSInteger)N{
	        if(N <= 1)return N;
	        return [self normal_fibFucntionIndex:N-1] + [self normal_fibFucntionIndex:N-2];	
     }
     
###### 3-2、优化方案(从下表0开始遍历，查找n-1次即可找到第N个斐波那契数；时间复杂度为O(n))

    /**< 2、优化方案计算斐波那契数列 */
    - (NSInteger)good_fibFunctionIndex:(NSInteger)N{
	    if(N <= 1)return N;
	    NSInteger first = 0,secend = 1,sum = 1;
	    for (int i = 0; i < N-1; i++) {
		  sum = first + secend;
		  first = secend;
		  secend = sum;
	    }
	    return sum;
    }

    

